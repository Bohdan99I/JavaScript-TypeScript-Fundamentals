/*
Типи даних в JavaScript та їх основна різниця:

JavaScript має 8 основних типів даних:

1. Примітивні типи:
   - String: рядок символів, наприклад, "hello".
   - Number: числовий тип, включаючи цілі числа та числа з плаваючою комою.
   - BigInt: великі цілі числа, які перевищують діапазон Number.
   - Boolean: логічний тип, який має два значення: true або false.
   - Undefined: значення, яке означає, що змінна не має присвоєного значення.
   - Null: спеціальне значення, яке представляє відсутність значення.
   - Symbol: унікальний і незмінний тип даних, який використовується як ідентифікатор для властивостей об'єктів.

2. Об'єктні типи:
   - Object: колекція властивостей і методів.
*/

/*
Різниця між `undefined` та `null`:

- undefined: означає, що змінна була оголошена, але не має присвоєного значення.
- null: є явно присвоєним значенням для змінної, яке вказує на відсутність будь-якого об'єкта чи значення.
*/

/*
Різниця між `var`, `let` та `const`:

- var: має функціональну область видимості, піддається підняттю (hoisting), може бути перевизначена та переприсвоєна.
- let: має блочну область видимості, піддається підняттю, але не може бути використана до оголошення, може бути переприсвоєна.
- const: має блочну область видимості, піддається підняттю, але не може бути використана до оголошення, не може бути переприсвоєна.
*/

/*
Різниця між ECMAScript та JavaScript:

- ECMAScript: це стандарт, на основі якого розробляються реалізації мов програмування, зокрема JavaScript.
- JavaScript: мова програмування, що реалізує специфікацію ECMAScript.
*/

/*
Динамічна типізація:

Динамічна типізація означає, що змінні можуть містити значення будь-якого типу і тип змінної може змінюватися під час виконання програми. Це також називають слабкою типізацією.
*/

/*
Варіанти додавання JS коду до сторінки:

1. Внутрішній JS: за допомогою тегу <script> безпосередньо в HTML-коді.
2. Зовнішній JS: за допомогою тегу <script src="path/to/file.js"></script>, посилаючись на зовнішній файл.
3. Інлайн JS: всередині HTML-атрибутів (наприклад, onclick="alert('Hello')").
*/

/*
Обмеження для коду, написаного на JS, який запускається в браузері:

1. Безпека: JS в браузері працює в ізольованому середовищі (пісочниця) для захисту від несанкціонованого доступу до системних ресурсів.
2. Доступ до файлової системи: обмежений.
3. Крос-доменний доступ: обмежений правилами політики одного джерела (same-origin policy).
*/

/*
Різниця між компільованою та інтерпретованою мовою програмування:

- Компільована мова: код компілюється в машинний код перед виконанням, що дозволяє швидше виконувати програми (наприклад, C, C++).
- Інтерпретована мова: код виконується безпосередньо інтерпретатором без попередньої компіляції (наприклад, Python, JavaScript).

JavaScript відноситься до інтерпретованих мов, хоча сучасні браузери часто використовують JIT-компіляцію (Just-In-Time), щоб покращити продуктивність.
*/

/*
Види операторів в JS:

1. Арифметичні оператори (+, -, *, /, %, ++, --)
2. Порівняльні оператори (==, ===, !=, !==, >, <, >=, <=)
3. Логічні оператори (&&, ||, !)
4. Бітові оператори (&, |, ^, ~, <<, >>, >>>)
5. Оператори присвоєння (=, +=, -=, *=, /=, %=)
6. Тернарний оператор (condition ? expr1 : expr2)
7. Оператори типу (typeof, instanceof)
8. Оператори роботи з рядками (+, +=)
*/

/*
Різниця між оператором == та ===, який краще використовувати:

- Оператор ==: виконує порівняння за значенням з приведенням типів.
- Оператор ===: виконує порівняння за значенням без приведення типів.

Краще використовувати оператор ===, оскільки він більш строгий і уникне небажаних результатів через неявне приведення типів.
*/

/*
Різниця між префіксним та постфіксним оператором ++, який краще використовувати:

- Префіксний (++i): збільшує значення змінної перед його використанням у виразі.
- Постфіксний (i++): збільшує значення змінної після його використання у виразі.

Краще використовувати префіксний оператор, коли важливо негайне збільшення значення, або постфіксний, коли потрібне значення перед збільшенням.
*/

/*
Що таке пріоритет операторів, на що він впливає:

Пріоритет операторів визначає порядок виконання операцій у виразі. Оператори з вищим пріоритетом виконуються раніше операторів з нижчим пріоритетом.
*/

/*
Як можна підвищити пріоритет оператора:

Пріоритет оператора можна підвищити за допомогою круглих дужок (), які змінюють стандартний порядок виконання операцій.
*/

/*
Від чого залежить результат роботи оператора:

Результат роботи оператора залежить від типів і значень операндів, а також від пріоритету і асоціативності операторів.
*/

/*
Які значення вважаються false при перетворенні до типу boolean:

- 0
- ""
- null
- undefined
- NaN
- false
*/

/*
Яка різниця між логічними та арифметичними операторами:

- Логічні оператори працюють з булевими значеннями і повертають булеві результати (&&, ||, !).
- Арифметичні оператори працюють з числами і повертають числові результати (+, -, *, /, %).
*/

/*
За яким принципом виконується оператор порівняння рядків 'str' > 'str':

Оператор порівняння рядків виконується за принципом лексикографічного порядку, порівнюючи коди символів по черзі.
*/

/*
Яка різниця між isNaN() та Number.isNaN():

- isNaN(): перевіряє, чи є значення NaN після неявного приведення до числа.
- Number.isNaN(): перевіряє, чи є значення строго NaN без приведення типів.
*/

/*
Які існують вбудовані способи перетворення рядка до типу number:

- Number("string")
- parseInt("string")
- parseFloat("string")
- Унарний плюс: +"string"
*/

/*
Що таке явне (explicit) та неявне (implicit) перетворення типів:

- Явне перетворення: коли програміст явно вказує на необхідність зміни типу (наприклад, Number("string")).
- Неявне перетворення: коли тип змінюється автоматично під час виконання виразу (наприклад, "5" * 2).
*/

/*
Чому результат даного виразу буде "null":

"" || "null" || false || undefined || 0 || "hello"

- Оператор || повертає перше true-значення або останнє false-значення.
- Першим true-значенням є "null", тому вираз поверне "null".
*/

/*
Чому результат даного виразу буде 0:

"false" && " " && 0 && undefined

- Оператор && повертає перше false-значення або останнє true-значення.
- Першим false-значенням є 0, тому вираз поверне 0.
*/

